########################################################################
##
## AMF_Bent_CDC
## Wangning Cai (William), University of British Columbia
## ver 18th March 2021
## 
########################################################################
import math
from SiEPIC.utils import get_technology, get_technology_by_name
from pya import *
import numpy as np


class AMF_Bent_CDC(PCellDeclarationHelper):
 
    '''
    the function returns a pcell of bent contra-directional-coupler
    using AMF technology
    
    '''

    def __init__(self):
    
        # Important: initialize the super class
        super(AMF_Bent_CDC, self).__init__()
        TECHNOLOGY = get_technology_by_name('AMF')
        
        # declare the parameters
        self.param("silayer", self.TypeLayer, "Si Layer", default=TECHNOLOGY['RIB (10/0@1)'])
        self.param("si3layer", self.TypeLayer, "SiEtch2(Rib) Layer", default=TECHNOLOGY['SLAB (12/0@1)'])
        #self.param("silayer", self.TypeLayer, "Si Layer", default = TECHNOLOGY['Waveguide'])
        self.param("silayer_gratings", self.TypeLayer, "Si Gratings Layer", default = TECHNOLOGY['Waveguide'])
        self.param("radius", self.TypeDouble, "Radius (um)", default = 100)
        self.param("gap", self.TypeDouble, "Gap (um)", default = 0.28)
        self.param("bus_width", self.TypeDouble, "Bus Width (um)", default = 0.45)
        self.param("ring_width", self.TypeDouble, "Ring Width (um)", default = 0.55)
        self.param("period", self.TypeDouble, "Gratings Period (nm)", default = 318)
        self.param("deltaWB", self.TypeDouble, "Bus Corrugation Width (um)", default = 0.04)
        self.param("deltaWR", self.TypeDouble, "Ring Corrugation Width (um)", default = 0.05)
        self.param("gamma", self.TypeDouble, "N (number of corrugations)", default = 540)
        self.param("busBend", self.TypeDouble, "Bus-to-straight bend raidus", default = 5)
        self.param("sinusoidal", self.TypeBoolean, "Grating Type (Rectangular=False, Sinusoidal=True)", default = False)
        self.param("anti_reflection", self.TypeBoolean, "anti reflection design (Rectangular=False, anti reflection=True)", default = True)
        self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
        self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
        # active heater is place excluding the grating region of the CDC
        self.param("heater", self.TypeBoolean, "heater (without heater=False, with heater=True)", default = True)
        self.param("heater_layer", self.TypeLayer, "Heater_Layer", default=TECHNOLOGY['HTR (115/0@1)'])
        self.param("heater_ring_width", self.TypeDouble, "Heater_Ring Width (um)", default = 2)
        # hidden parameters, can be used to query this component:
        self.param("p1", self.TypeShape, "DPoint location of pin1", default = Point(-10000, 0), hidden = True, readonly = True)
        self.param("p2", self.TypeShape, "DPoint location of pin2", default = Point(0, 10000), hidden = True, readonly = True)
        
    def display_text_impl(self):
        # Provide a descriptive text for the cell
        return "AMF_Bent_CDC(R=" + ('%.3f' % self.radius) + ")"
        
    def produce_impl(self):
        #def produce(self, layout, layers, parameters, cell):
        '''
        cell: layout cell to place the layout
        layers: which layer to use
        r: radius
        w: waveguide Width
        length units in dbu
        '''
        
        #self._layers = layers
        #self.cell = cell
        #self._param = parameters
        #self.layout = layout
        
        from SiEPIC._globals import PIN_LENGTH as pin_length
        
        #from math import pi, cos, sin
        #from SiEPIC.extend import to_itype
        
        # fetch the parameters
        dbu = self.layout.dbu
        ly = self.layout
        shapes = self.cell.shapes
        
        LayerSi3N = ly.layer(self.si3layer)
        LayerSiN = ly.layer(self.silayer)
        LayerPinRecN = ly.layer(self.pinrec)
        LayerDevRecN = ly.layer(self.devrec)
        LayerHeater = ly.layer(self.heater_layer)
        
        
        # Center of everything
        x = 0
        y = 0 
        
        # step size distance between each coordinate 
        num_points = 0.001 
        
        from SiEPIC.extend import to_itype
        from math import pi
        
        # parameters 
        
        w_bus = to_itype(self.bus_width,dbu)
        w_ring = to_itype(self.ring_width,dbu)
        w = w_ring 
        r = int(round(self.radius/dbu))
        gap = int(round(self.gap/dbu))
        period = self.period
        deltaWR = int(round(self.deltaWR/dbu))
        N = int(self.gamma)
        deltaWB = int(round(self.deltaWB/dbu))
        busBendR = int(round(self.busBend/dbu))
        
        w_heater = to_itype(self.heater_ring_width,dbu)

        # angle of coorigation
        
        from SiEPIC.utils import points_per_circle,arc_wg_xy
        theta = N*period/(r)
        theta_start = (pi - theta)/2 
        theta_finish = (theta_start + theta)
        

        if not(self.sinusoidal):
            if self.anti_reflection:
                # lower edge of the ring
                
                i = 0
                xd1=0
                yd1=0
                r_coord = [] # ring coordinates
                
                angle_array = []
                theta_current = theta_start
                num_coorg = N-1
                
                # #lower edge add on 0
        
                # xadd = (r - w_ring/2)*math.cos(theta_start)
                # yadd = (r - w_ring/2)*math.sin(theta_start) 
                
                # r_coord.append(Point.from_dpoint(DPoint(xadd,yadd)))
                
                while i <= num_coorg:
                    angle_array.append(theta_current)
                    theta_current = theta_current + period/r
                    i = i + 1
                    
                
                
                i = 0
                for i in angle_array:
                    xd0 = (r - w_ring/2 + deltaWR/2)*math.cos(i)
                    yd0 = (r - w_ring/2 + deltaWR/2)*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd0,yd0)))

                    xd1 = (r - w_ring/2 - deltaWR/2)*math.cos(i)
                    yd1 = (r - w_ring/2 - deltaWR/2)*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))

                    xd2 = (r - w_ring/2 - deltaWR/2)*math.cos(i+(period/(r))/2)
                    yd2 = (r - w_ring/2 - deltaWR/2)*math.sin(i+(period/(r))/2)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))

                    xd3 = (r - w_ring/2 + deltaWR/2)*math.cos(i+(period/(r))/2)
                    yd3 = (r - w_ring/2 + deltaWR/2)*math.sin(i+(period/(r))/2)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd3,yd3)))

                xd4 = (r - w_ring/2 + deltaWR/2)*math.cos(theta_finish)
                yd4 = (r - w_ring/2 + deltaWR/2)*math.sin(theta_finish)
                    
                r_coord.append(Point.from_dpoint(DPoint(xd4,yd4)))
                # #lower edge add on 1
                # xadd1 = (r - w_ring/2)*math.cos(theta_finish)
                # yadd1 = (r - w_ring/2)*math.sin(theta_finish)
                
                # r_coord.append(Point.from_dpoint(DPoint(xadd1,yadd1)))    
                # upper edge of the ring
                i=0  
                angle_array1 = []
                theta_current = theta_finish

                # #upper edge add on 2
                # xadd2 = (r + w_ring/2)*math.cos(theta_finish)
                # yadd2 = (r + w_ring/2)*math.sin(theta_finish)
                
                # r_coord.append(Point.from_dpoint(DPoint(xadd2,yadd2)))

                while i <= num_coorg:
                    angle_array1.append(theta_current)
                    theta_current = theta_current-period/r
                    i = i + 1
                
                for i in angle_array1:
                    xd0 = (r + w_ring/2 + deltaWR/2)*math.cos(i)
                    yd0 = (r + w_ring/2 + deltaWR/2)*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd0,yd0)))

                    xd2 = (r + w_ring/2 + deltaWR/2)*math.cos(i-(period/(r))/2)
                    yd2 = (r + w_ring/2 + deltaWR/2)*math.sin(i-(period/(r))/2)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))

                    xd3 = (r + w_ring/2 - deltaWR/2)*math.cos(i-(period/(r))/2)
                    yd3 = (r + w_ring/2 - deltaWR/2)*math.sin(i-(period/(r))/2)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd3,yd3)))

                    xd1 = (r + w_ring/2 - deltaWR/2)*math.cos(i-period/(r))
                    yd1 = (r + w_ring/2 - deltaWR/2)*math.sin(i-(period/(r)))
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))
                
                # #upper edge add on 3
                # xadd3 = (r + w_ring/2)*math.cos(theta_start)
                # yadd3 = (r + w_ring/2)*math.sin(theta_start)

                # r_coord.append(Point.from_dpoint(DPoint(xadd3,yadd3)))

                polygon = Polygon(r_coord)
                self.cell.shapes(LayerSiN).insert(polygon)
                
                # lower edge of the bus 
                
                ii = 0 
                
                b_coord = [] #bus coordinate

                # #lower edge add on 4
        
                # xadd4 = (r + w_ring/2 + gap )*math.cos(theta_start)
                # yadd4 = (r + w_ring/2 + gap )*math.sin(theta_start) 
                
                # b_coord.append(Point.from_dpoint(DPoint(xadd4,yadd4)))
                
                for ii in angle_array:
                    xd0 = (r + w_ring/2 +gap  + deltaWB/2)*math.cos(ii)
                    yd0 = (r + w_ring/2 +gap  + deltaWB/2)*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd0,yd0)))

                    xd1 = (r + w_ring/2 +gap  - deltaWB/2)*math.cos(ii)
                    yd1 = (r + w_ring/2 +gap  - deltaWB/2)*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))

                    xd2 = (r + w_ring/2 +gap  - deltaWB/2)*math.cos(ii+(period/r)/2)
                    yd2 = (r + w_ring/2 +gap  - deltaWB/2)*math.sin(ii+(period/r)/2)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))

                    xd3 = (r + w_ring/2 +gap  + deltaWB/2)*math.cos(ii+(period/r)/2)
                    yd3 = (r + w_ring/2 +gap  + deltaWB/2)*math.sin(ii+(period/r)/2)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd3,yd3)))

                xd4 = (r + w_ring/2 +gap  + deltaWB/2)*math.cos(theta_finish)
                yd4 = (r + w_ring/2 +gap  + deltaWB/2)*math.sin(theta_finish)
                    
                b_coord.append(Point.from_dpoint(DPoint(xd4,yd4)))

                # #lower edge add on 5
        
                # xadd5 = (r + w_ring/2 + gap )*math.cos(theta_finish)
                # yadd5 = (r + w_ring/2 + gap )*math.sin(theta_finish) 
                
                # b_coord.append(Point.from_dpoint(DPoint(xadd5,yadd5)))  

                # upper edge of the bus

                # #upper edge add on 6
        
                # xadd6 = (r + w_ring/2 + gap + w_bus)*math.cos(theta_finish +period/r)
                # yadd6 = (r + w_ring/2 + gap + w_bus)*math.sin(theta_finish +period/r) 
                
                # b_coord.append(Point.from_dpoint(DPoint(xadd6,yadd6)))

                ii = 0
                for ii in angle_array1:
                    
                    xd0 = (r + w_ring/2+gap+w_bus + deltaWB/2)*math.cos(ii)
                    yd0 = (r + w_ring/2+gap+w_bus + deltaWB/2)*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd0,yd0)))

                    xd2 = (r + w_ring/2+gap+w_bus + deltaWB/2)*math.cos(ii-(period/(r))/2)
                    yd2 = (r + w_ring/2+gap+w_bus + deltaWB/2)*math.sin(ii-(period/(r))/2)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))

                    xd3 = (r + w_ring/2+gap+w_bus - deltaWB/2)*math.cos(ii-(period/(r))/2)
                    yd3 = (r + w_ring/2+gap+w_bus - deltaWB/2)*math.sin(ii-(period/(r))/2)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd3,yd3)))

                    xd1 = (r + w_ring/2+gap+w_bus - deltaWB/2)*math.cos(ii-period/(r))
                    yd1 = (r + w_ring/2+gap+w_bus - deltaWB/2)*math.sin(ii-(period/(r)))
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))

                # #upper edge add on 7
        
                # xadd7 = (r + w_ring/2 + gap + w_bus)*math.cos(theta_start)
                # yadd7 = (r + w_ring/2 + gap + w_bus)*math.sin(theta_start)
                
                # b_coord.append(Point.from_dpoint(DPoint(xadd7,yadd7)))

                polygon = Polygon(b_coord)
                self.cell.shapes(LayerSiN).insert(polygon) 
                
                N = N
                theta = N*period/(r)
                theta_start = (pi - theta)/2 
                theta_finish = (theta_start + theta)
                
                # fill the gaps
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring-2.5*deltaWR,theta_start*180/pi,theta_finish*180/pi))
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r+gap+w_ring/2+w_bus/2,w_bus-2.5*deltaWB,theta_start*180/pi,theta_finish*180/pi))

                
                # ring non-cdc left
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring,0,theta_start*180/pi+0.01))
                
                #ring non-cdc right
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring,theta_finish*180/pi-0.01,180))
            
            else:
                # lower edge of the ring
                
                i = 0
                xd1=0
                yd1=0
                r_coord = [] # ring coordinates
                
                angle_array = []
                theta_current = theta_start
                num_coorg = N-1

                # #lower edge add on 0
        
                # xadd = (r - w_ring/2)*math.cos(theta_start)
                # yadd = (r - w_ring/2)*math.sin(theta_start) 
                
                # r_coord.append(Point.from_dpoint(DPoint(xadd,yadd)))

                while i <= num_coorg:
                    angle_array.append(theta_current)
                    theta_current = theta_current + period/r
                    i = i + 1
                    
                
                
                i = 0
                for i in angle_array:
                    xd0 = (r - w_ring/2 + deltaWR/2)*math.cos(i)
                    yd0 = (r - w_ring/2 + deltaWR/2)*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd0,yd0)))

                    xd1 = (r - w_ring/2 - deltaWR/2)*math.cos(i)
                    yd1 = (r - w_ring/2 - deltaWR/2)*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))

                    xd2 = (r - w_ring/2 - deltaWR/2)*math.cos(i+(period/(r))/2)
                    yd2 = (r - w_ring/2 - deltaWR/2)*math.sin(i+(period/(r))/2)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))

                    xd3 = (r - w_ring/2 + deltaWR/2)*math.cos(i+(period/(r))/2)
                    yd3 = (r - w_ring/2 + deltaWR/2)*math.sin(i+(period/(r))/2)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd3,yd3)))

                xd4 = (r - w_ring/2 + deltaWR/2)*math.cos(theta_finish)
                yd4 = (r - w_ring/2 + deltaWR/2)*math.sin(theta_finish)
                    
                r_coord.append(Point.from_dpoint(DPoint(xd4,yd4)))
                
                # #lower edge add on 1
                # xadd1 = (r - w_ring/2)*math.cos(theta_finish)
                # yadd1 = (r - w_ring/2)*math.sin(theta_finish)
                
                # r_coord.append(Point.from_dpoint(DPoint(xadd1,yadd1)))    

                # upper edge of the ring
                i=0  
                angle_array1 = []
                theta_current = theta_finish

                # #upper edge add on 2
                # xadd2 = (r + w_ring/2)*math.cos(theta_finish)
                # yadd2 = (r + w_ring/2)*math.sin(theta_finish)
                
                # r_coord.append(Point.from_dpoint(DPoint(xadd2,yadd2)))

                while i <= num_coorg:
                    angle_array1.append(theta_current)
                    theta_current = theta_current-period/r
                    i = i + 1
                
                i=0
                for i in angle_array1:
                    xd0 = (r + w_ring/2 - deltaWR/2)*math.cos(i)
                    yd0 = (r + w_ring/2 - deltaWR/2)*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd0,yd0)))

                    xd2 = (r + w_ring/2 - deltaWR/2)*math.cos(i-(period/(r))/2)
                    yd2 = (r + w_ring/2 - deltaWR/2)*math.sin(i-(period/(r))/2)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))

                    xd3 = (r + w_ring/2 + deltaWR/2)*math.cos(i-(period/(r))/2)
                    yd3 = (r + w_ring/2 + deltaWR/2)*math.sin(i-(period/(r))/2)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd3,yd3)))

                    xd1 = (r + w_ring/2 + deltaWR/2)*math.cos(i-period/(r))
                    yd1 = (r + w_ring/2 + deltaWR/2)*math.sin(i-(period/(r)))
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))
                

                # #upper edge add on 3
                # xadd3 = (r + w_ring/2)*math.cos(theta_start)
                # yadd3 = (r + w_ring/2)*math.sin(theta_start)
                
                # r_coord.append(Point.from_dpoint(DPoint(xadd3,yadd3)))

                polygon = Polygon(r_coord)
                self.cell.shapes(LayerSiN).insert(polygon)
                
                # lower edge of the bus 
                
                ii = 0 
                
                b_coord = [] #bus coordinate
                
                # #lower edge add on 4
        
                # xadd4 = (r + w_ring/2 + gap )*math.cos(theta_start)
                # yadd4 = (r + w_ring/2 + gap )*math.sin(theta_start) 

                # b_coord.append(Point.from_dpoint(DPoint(xadd4,yadd4)))


                for ii in angle_array:
                    xd0 = (r + w_ring/2 +gap  + deltaWB/2)*math.cos(ii)
                    yd0 = (r + w_ring/2 +gap  + deltaWB/2)*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd0,yd0)))

                    xd1 = (r + w_ring/2 +gap  - deltaWB/2)*math.cos(ii)
                    yd1 = (r + w_ring/2 +gap  - deltaWB/2)*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))

                    xd2 = (r + w_ring/2 +gap  - deltaWB/2)*math.cos(ii+(period/r)/2)
                    yd2 = (r + w_ring/2 +gap  - deltaWB/2)*math.sin(ii+(period/r)/2)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))

                    xd3 = (r + w_ring/2 +gap  + deltaWB/2)*math.cos(ii+(period/r)/2)
                    yd3 = (r + w_ring/2 +gap  + deltaWB/2)*math.sin(ii+(period/r)/2)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd3,yd3)))

                xd4 = (r + w_ring/2 +gap  + deltaWB/2)*math.cos(theta_finish)
                yd4 = (r + w_ring/2 +gap  + deltaWB/2)*math.sin(theta_finish)
                    
                b_coord.append(Point.from_dpoint(DPoint(xd4,yd4)))
                    

                # #lower edge add on 5
        
                # xadd5 = (r + w_ring/2 + gap )*math.cos(theta_finish)
                # yadd5 = (r + w_ring/2 + gap )*math.sin(theta_finish) 
                
                # b_coord.append(Point.from_dpoint(DPoint(xadd5,yadd5)))

                # upper edge of the bus

                # #upper edge add on 6
        
                # xadd6 = (r + w_ring/2 + gap + w_bus)*math.cos(theta_finish)
                # yadd6 = (r + w_ring/2 + gap + w_bus)*math.sin(theta_finish) 
                
                # b_coord.append(Point.from_dpoint(DPoint(xadd6,yadd6)))

                ii=0

                for ii in angle_array1:
                    
                    xd0 = (r + w_ring/2+gap+w_bus - deltaWB/2)*math.cos(ii)
                    yd0 = (r + w_ring/2+gap+w_bus - deltaWB/2)*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd0,yd0)))

                    xd2 = (r + w_ring/2+gap+w_bus - deltaWB/2)*math.cos(ii-(period/(r))/2)
                    yd2 = (r + w_ring/2+gap+w_bus - deltaWB/2)*math.sin(ii-(period/(r))/2)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))

                    xd3 = (r + w_ring/2+gap+w_bus + deltaWB/2)*math.cos(ii-(period/(r))/2)
                    yd3 = (r + w_ring/2+gap+w_bus + deltaWB/2)*math.sin(ii-(period/(r))/2)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd3,yd3)))

                    xd1 = (r + w_ring/2+gap+w_bus + deltaWB/2)*math.cos(ii-period/(r))
                    yd1 = (r + w_ring/2+gap+w_bus + deltaWB/2)*math.sin(ii-(period/(r)))
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))
                    

                # #upper edge add on 7
        
                # xadd7 = (r + w_ring/2 + gap + w_bus)*math.cos(theta_start)
                # yadd7 = (r + w_ring/2 + gap + w_bus)*math.sin(theta_start)
                
                # b_coord.append(Point.from_dpoint(DPoint(xadd7,yadd7)))

                polygon = Polygon(b_coord)
                self.cell.shapes(LayerSiN).insert(polygon) 
                
                N = N
                theta = N*period/(r)
                theta_start = (pi - theta)/2 
                theta_finish = (theta_start + theta)
                
                # fill the gaps
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring-2.5*deltaWR,theta_start*180/pi,theta_finish*180/pi))
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r+gap+w_ring/2+w_bus/2,w_bus-2.5*deltaWB,theta_start*180/pi,theta_finish*180/pi))

                
                # ring non-cdc left
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring,0,theta_start*180/pi+0.01))
                
                #ring non-cdc right
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring,theta_finish*180/pi-0.01,180))
        
            #draw bus non-cdc Waveguide
            
            r_bus = r + w_ring/2 + gap + w_bus/2
            y_center = r_bus*math.cos(theta/2) + busBendR*math.cos(theta/2)
            x_center = r_bus*math.sin(theta/2) + busBendR*math.sin(theta/2)
            
            self.cell.shapes(LayerSiN).insert(arc_wg_xy(x_center,y_center,busBendR,w_bus,270- 0.1-theta*(180/pi)/2 ,270))
            self.cell.shapes(LayerSiN).insert(arc_wg_xy(-x_center,y_center,busBendR,w_bus,270,270- 0.1-theta*(180/pi)/2 ))
            
            # Pin on the right:
            y_center = r_bus * math.cos(theta/2) + busBendR * math.cos(theta/2) - busBendR + 1
            p2 = [Point(-pin_length/2 +x_center, y_center), Point(pin_length/2 +x_center, y_center)]
            p2c = Point(x_center, y_center)
            self.set_p2 = p2c
            self.p2 = p2c
            pin = Path(p2, w_bus)
            self.cell.shapes(LayerPinRecN).insert(pin)
            t = Trans(Trans.R0, x_center, y_center)
            text = Text ("pin2", t)
            shape = self.cell.shapes(LayerPinRecN).insert(text)
            shape.text_size = 0.4/dbu
            # Pin on the left side:
            x_center = -x_center
            p1 = [Point(pin_length/2 +x_center, y_center), Point(-pin_length/2 +x_center, y_center)]
            p1c = Point(x_center, y_center)
            self.set_p1 = p1c
            self.p1 = p1c
            pin = Path(p1, w_bus)
            self.cell.shapes(LayerPinRecN).insert(pin)
            t = Trans(Trans.R0, x_center, y_center)
            text = Text ("pin1", t)
            shape = self.cell.shapes(LayerPinRecN).insert(text)
            shape.text_size = 0.4/dbu
            
            # Pin on the bottom left side:
            p3 = [Point(x-r, pin_length/2 +y), Point(x-r, -pin_length/2 +y)]
            p3c = Point(x-r, y)
            self.set_p3 = p3c
            self.p3 = p3c
            pin = Path(p3, w_ring)
            self.cell.shapes(LayerPinRecN).insert(pin)
            t = Trans(Trans.R0, x-r, y)
            text = Text ("pin3", t)
            shape = self.cell.shapes(LayerPinRecN).insert(text)
            shape.text_size = 0.4/dbu
            
            # Pin on the bottom right side:
            p4 = [Point(x+r, y+pin_length/2), Point(x+r,y-pin_length/2)]
            p4c = Point(x+r,y)
            self.set_p4 = p4c
            self.p4 = p4c
            pin = Path(p4, w_ring)
            self.cell.shapes(LayerPinRecN).insert(pin)
            t = Trans(Trans.R0, x+r, y)
            text = Text ("pin4", t)
            shape = self.cell.shapes(LayerPinRecN).insert(text)
            shape.text_size = 0.4/dbu
            # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
            self.cell.shapes(LayerDevRecN).insert(arc_wg_xy(x ,y, r+gap, w*5, 0, 180))

        else:
            if self.anti_reflection:
                # lower edge of the ring
        
                i = 0
                xd1=0
                yd1=0
                r_coord = [] # ring coordinates
                
                angle_array = []
                theta_current = theta_start
                num_coorg = theta/num_points
                
                
                
                while i <= num_coorg:
                    angle_array.append(theta_current)
                    theta_current = theta_current + num_points
                    i = i + 1
                    
                #lower edge add on 0
                
                xadd = (r - w_ring/2)*math.cos(theta_start -period/r)
                yadd = (r - w_ring/2)*math.sin(theta_start -period/r) 
                
                r_coord.append(Point.from_dpoint(DPoint(xadd,yadd)))
                
                
                i = 0
                for i in angle_array:
                    xd1 = (r - w_ring/2 + deltaWR*math.sin(N*i))*math.cos(i)
                    yd1 = (r - w_ring/2 + deltaWR*math.sin(N*i))*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))
                
                #lower edge add on 1
                xadd1 = (r - w_ring/2)*math.cos(theta_finish +period/r)
                yadd1 = (r - w_ring/2)*math.sin(theta_finish +period/r)
                
                r_coord.append(Point.from_dpoint(DPoint(xadd1,yadd1)))    
                # upper edge of the ring
                
                i=0  
                angle_array1 = []
                theta_current = theta_finish
                
                #upper edge add on 2
                xadd2 = (r + w_ring/2)*math.cos(theta_finish +period/r)
                yadd2 = (r + w_ring/2)*math.sin(theta_finish +period/r)
                
                r_coord.append(Point.from_dpoint(DPoint(xadd2,yadd2)))
                
                
                while i <= num_coorg:
                    angle_array1.append(theta_current)
                    theta_current = theta_current - num_points
                    i = i + 1
                
                xu1 = 0
                yu1 = 0
                
                
                for i in angle_array1:
                    xu1 = (r + w_ring/2 + deltaWR*math.sin(N*i))*math.cos(i)
                    yu1 = (r + w_ring/2 + deltaWR*math.sin(N*i))*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xu1,yu1)))
                
                #upper edge add on 3
                xadd3 = (r + w_ring/2)*math.cos(theta_start - period/r)
                yadd3 = (r + w_ring/2)*math.sin(theta_start - period/r)
                
                r_coord.append(Point.from_dpoint(DPoint(xadd3,yadd3)))
                
                polygon = Polygon(r_coord)
                self.cell.shapes(LayerSiN).insert(polygon)
                
                
                # lower edge of the bus 
                
                ii = 0 
                xd2= 0
                yd2= 0
                b_coord = [] #bus coordinate
                
                #lower edge add on 4
                
                xadd4 = (r + w_ring/2 + gap )*math.cos(theta_start -period/r)
                yadd4 = (r + w_ring/2 + gap )*math.sin(theta_start -period/r) 
                
                b_coord.append(Point.from_dpoint(DPoint(xadd4,yadd4)))
                
                for ii in angle_array:
                    xd2 =(r + w_ring/2 + gap  +deltaWB*math.sin(N*ii+deltaWR/deltaWB+pi/2))*math.cos(ii)
                    yd2 =(r + w_ring/2 + gap  +deltaWB*math.sin(N*ii+deltaWR/deltaWB+pi/2))*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))
                    
                #lower edge add on 5
                
                xadd5 = (r + w_ring/2 + gap )*math.cos(theta_finish +period/r)
                yadd5 = (r + w_ring/2 + gap )*math.sin(theta_finish +period/r) 
                
                b_coord.append(Point.from_dpoint(DPoint(xadd5,yadd5)))  
                
                # upper edge of the bus
                
                xu2 = 0
                yu2 = 0
                #upper edge add on 6
                
                xadd6 = (r + w_ring/2 + gap + w_bus)*math.cos(theta_finish +period/r)
                yadd6 = (r + w_ring/2 + gap + w_bus)*math.sin(theta_finish +period/r) 
                
                b_coord.append(Point.from_dpoint(DPoint(xadd6,yadd6)))

                for ii in angle_array1:
                    xu2 =(r + w_ring/2 + gap + w_bus +deltaWB*math.sin(N*ii+deltaWR/deltaWB+pi/2))*math.cos(ii)
                    yu2 =(r + w_ring/2 + gap + w_bus +deltaWB*math.sin(N*ii+deltaWR/deltaWB+pi/2))*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xu2,yu2)))
                    
                #upper edge add on 7
                
                xadd7 = (r + w_ring/2 + gap + w_bus)*math.cos(theta_start -period/r)
                yadd7 = (r + w_ring/2 + gap + w_bus)*math.sin(theta_start -period/r)
                
                b_coord.append(Point.from_dpoint(DPoint(xadd7,yadd7)))
                
                polygon = Polygon(b_coord)
                self.cell.shapes(LayerSiN).insert(polygon)
                
                N = N+2
                theta = N*period/(r)
                theta_start = (pi - theta)/2 
                theta_finish = (theta_start + theta)
                
                # fill the gaps
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring-2.5*deltaWR,theta_start*180/pi,theta_finish*180/pi))
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r+gap+w_ring/2+w_bus/2,w_bus-2.5*deltaWB,theta_start*180/pi,theta_finish*180/pi))
                
                
                # ring non-cdc left
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring,0,theta_start*180/pi))
                
                #ring non-cdc right
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring,theta_finish*180/pi,180))
                
                #draw bus non-cdc Waveguide
                
                r_bus = r + w_ring/2 + gap + w_bus/2
                y_center = r_bus*math.cos(theta/2) + busBendR*math.cos(theta/2)
                x_center = r_bus*math.sin(theta/2) + busBendR*math.sin(theta/2)
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x_center,y_center,busBendR,w_bus,270-theta*(180/pi)/2,270))
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(-x_center,y_center,busBendR,w_bus,270,270-theta*(180/pi)/2))
            else:
                # lower edge of the ring
        
                i = 0
                xd1=0
                yd1=0
                r_coord = [] # ring coordinates
                
                angle_array = []
                theta_current = theta_start
                num_coorg = theta/num_points
                
                
                
                while i <= num_coorg:
                    angle_array.append(theta_current)
                    theta_current = theta_current + num_points
                    i = i + 1
                    
                #lower edge add on 0
                
                xadd = (r - w_ring/2)*math.cos(theta_start -period/r)
                yadd = (r - w_ring/2)*math.sin(theta_start -period/r) 
                
                r_coord.append(Point.from_dpoint(DPoint(xadd,yadd)))
                
                
                i = 0
                for i in angle_array:
                    xd1 = (r - w_ring/2 + deltaWR*math.sin(N*i))*math.cos(i)
                    yd1 = (r - w_ring/2 + deltaWR*math.sin(N*i))*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xd1,yd1)))
                
                #lower edge add on 1
                xadd1 = (r - w_ring/2)*math.cos(theta_finish +period/r)
                yadd1 = (r - w_ring/2)*math.sin(theta_finish +period/r)
                
                r_coord.append(Point.from_dpoint(DPoint(xadd1,yadd1)))    
                # upper edge of the ring
                
                i=0  
                angle_array1 = []
                theta_current = theta_finish
                
                #upper edge add on 2
                xadd2 = (r + w_ring/2)*math.cos(theta_finish +period/r)
                yadd2 = (r + w_ring/2)*math.sin(theta_finish +period/r)
                
                r_coord.append(Point.from_dpoint(DPoint(xadd2,yadd2)))
                
                
                while i <= num_coorg:
                    angle_array1.append(theta_current)
                    theta_current = theta_current - num_points
                    i = i + 1
                
                xu1 = 0
                yu1 = 0
                
                
                for i in angle_array1:
                    xu1 = (r + w_ring/2 + deltaWR*math.sin(N*i+pi))*math.cos(i)
                    yu1 = (r + w_ring/2 + deltaWR*math.sin(N*i+pi))*math.sin(i)
                    
                    r_coord.append(Point.from_dpoint(DPoint(xu1,yu1)))
                
                #upper edge add on 3
                xadd3 = (r + w_ring/2)*math.cos(theta_start - period/r)
                yadd3 = (r + w_ring/2)*math.sin(theta_start - period/r)
                
                r_coord.append(Point.from_dpoint(DPoint(xadd3,yadd3)))
                
                polygon = Polygon(r_coord)
                self.cell.shapes(LayerSiN).insert(polygon)
                
                
                # lower edge of the bus 
                
                ii = 0 
                xd2= 0
                yd2= 0
                b_coord = [] #bus coordinate
                
                #lower edge add on 4
                
                xadd4 = (r + w_ring/2 + gap )*math.cos(theta_start -period/r)
                yadd4 = (r + w_ring/2 + gap )*math.sin(theta_start -period/r) 
                
                b_coord.append(Point.from_dpoint(DPoint(xadd4,yadd4)))
                
                for ii in angle_array:
                    xd2 =(r + w_ring/2 + gap  +deltaWB*math.sin(N*ii+deltaWR/deltaWB+3*pi/2))*math.cos(ii)
                    yd2 =(r + w_ring/2 + gap  +deltaWB*math.sin(N*ii+deltaWR/deltaWB+3*pi/2))*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xd2,yd2)))
                    
                #lower edge add on 5
                
                xadd5 = (r + w_ring/2 + gap )*math.cos(theta_finish +period/r)
                yadd5 = (r + w_ring/2 + gap )*math.sin(theta_finish +period/r) 
                
                b_coord.append(Point.from_dpoint(DPoint(xadd5,yadd5)))  
                
                # upper edge of the bus
                
                xu2 = 0
                yu2 = 0
                #upper edge add on 6
                
                xadd6 = (r + w_ring/2 + gap + w_bus)*math.cos(theta_finish +period/r)
                yadd6 = (r + w_ring/2 + gap + w_bus)*math.sin(theta_finish +period/r) 
                
                b_coord.append(Point.from_dpoint(DPoint(xadd6,yadd6)))

                for ii in angle_array1:
                    xu2 =(r + w_ring/2 + gap + w_bus +deltaWB*math.sin(N*ii+deltaWR/deltaWB+pi/2))*math.cos(ii)
                    yu2 =(r + w_ring/2 + gap + w_bus +deltaWB*math.sin(N*ii+deltaWR/deltaWB+pi/2))*math.sin(ii)
                    
                    b_coord.append(Point.from_dpoint(DPoint(xu2,yu2)))
                    
                #upper edge add on 7
                
                xadd7 = (r + w_ring/2 + gap + w_bus)*math.cos(theta_start -period/r)
                yadd7 = (r + w_ring/2 + gap + w_bus)*math.sin(theta_start -period/r)
                
                b_coord.append(Point.from_dpoint(DPoint(xadd7,yadd7)))
                
                polygon = Polygon(b_coord)
                self.cell.shapes(LayerSiN).insert(polygon)
                
                N = N+2
                theta = N*period/(r)
                theta_start = (pi - theta)/2 
                theta_finish = (theta_start + theta)
                
                # fill the gaps
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring-2.5*deltaWR,theta_start*180/pi,theta_finish*180/pi))
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r+gap+w_ring/2+w_bus/2,w_bus-2.5*deltaWB,theta_start*180/pi,theta_finish*180/pi))
                
                
                # ring non-cdc left
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring,0,theta_start*180/pi))
                
                #ring non-cdc right
                
                self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y,r,w_ring,theta_finish*180/pi,180))
                
            #draw bus non-cdc Waveguide
                
            r_bus = r + w_ring/2 + gap + w_bus/2
            y_center = r_bus*math.cos(theta/2) + busBendR*math.cos(theta/2)
            x_center = r_bus*math.sin(theta/2) + busBendR*math.sin(theta/2)
                
            self.cell.shapes(LayerSiN).insert(arc_wg_xy(x_center,y_center,busBendR,w_bus,270-theta*(180/pi)/2,270))
            self.cell.shapes(LayerSiN).insert(arc_wg_xy(-x_center,y_center,busBendR,w_bus,270,270-theta*(180/pi)/2))
                
            # Pin on the right:
            y_center = r_bus * math.cos(theta/2) + busBendR * math.cos(theta/2) - busBendR + 1
            p2 = [Point(-pin_length/2 +x_center, y_center), Point(pin_length/2 +x_center, y_center)]
            p2c = Point(x_center, y_center)
            self.set_p2 = p2c
            self.p2 = p2c
            pin = Path(p2, w_bus)
            self.cell.shapes(LayerPinRecN).insert(pin)
            t = Trans(Trans.R0, x_center, y_center)
            text = Text ("pin2", t)
            shape = self.cell.shapes(LayerPinRecN).insert(text)
            shape.text_size = 0.4/dbu
            # Pin on the left side:
            x_center = -x_center
            p1 = [Point(pin_length/2 +x_center, y_center), Point(-pin_length/2 +x_center, y_center)]
            p1c = Point(x_center, y_center)
            self.set_p1 = p1c
            self.p1 = p1c
            pin = Path(p1, w_bus)
            self.cell.shapes(LayerPinRecN).insert(pin)
            t = Trans(Trans.R0, x_center, y_center)
            text = Text ("pin1", t)
            shape = self.cell.shapes(LayerPinRecN).insert(text)
            shape.text_size = 0.4/dbu
            
            # Pin on the bottom left side:
            p3 = [Point(x-r, pin_length/2 +y), Point(x-r, -pin_length/2 +y)]
            p3c = Point(x-r, y)
            self.set_p3 = p3c
            self.p3 = p3c
            pin = Path(p3, w_ring)
            self.cell.shapes(LayerPinRecN).insert(pin)
            t = Trans(Trans.R0, x-r, y)
            text = Text ("pin3", t)
            shape = self.cell.shapes(LayerPinRecN).insert(text)
            shape.text_size = 0.4/dbu
            
            # Pin on the bottom right side:
            p4 = [Point(x+r, y+pin_length/2), Point(x+r,y-pin_length/2)]
            p4c = Point(x+r,y)
            self.set_p4 = p4c
            self.p4 = p4c
            pin = Path(p4, w_ring)
            self.cell.shapes(LayerPinRecN).insert(pin)
            t = Trans(Trans.R0, x+r, y)
            text = Text ("pin4", t)
            shape = self.cell.shapes(LayerPinRecN).insert(text)
            shape.text_size = 0.4/dbu
            # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
            self.cell.shapes(LayerDevRecN).insert(arc_wg_xy(x ,y, r+gap, w*5, 0, 180))
        # draw heater layer
        if self.heater: 
            self.cell.shapes(LayerHeater).insert(arc_wg_xy(x,y,r,w_heater,0,theta_start*180/pi))
            self.cell.shapes(LayerHeater).insert(arc_wg_xy(x,y,r,w_heater,theta_finish*180/pi,180))
        
        
class SIEPIC_Demo(Library):


  def __init__(self):
  
    tech_name = 'AMF_Personal'
    library = tech_name
    
    print("Initializing '%s' Library." % library)
    
    self.description = ""
    self.description = 'AMF bend CDCs'
    # self.layout().register_pcell("AMF_reg_CDC",AMF_reg_CDC())
    # self.layout().register_pcell("Strip_To_slot", Strip_To_Slot())
    # self.layout().register_pcell("AMF_sin_CDC",AMF_sin_CDC())
    self.layout().register_pcell("AMF_Bent_CDC",AMF_Bent_CDC())
    #self.layout().register_pcell("Spiral",Spiral())
    self.register(library)
    self.technology='AMF'
    
SIEPIC_Demo()
